%{
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fstream>
#include <sstream>

#include "Configuration2.hpp"
//#include "Value.hpp"

#define YYSTYPE char *

extern int yylex();
extern int yyparse();
extern FILE* yyin;

void yyerror(const char* s);

Configuration configuration;
std::map<std::string, std::pair<Value, std::list<Value*>>> temp_assignments;
const std::list<Value*> temp_empty_list;

bool to_bool(std::string str) {
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
    std::istringstream is(str);
    bool b;
    is >> std::boolalpha >> b;
    return b;
}
%}

%token NUMBER BOOL WORD REFPATH STRING OPEN_SQUARE CLOSED_SQUARE EQUALS
%%

sections:
    // empty
    |
    sections section {
    }
;

section: 
    OPEN_SQUARE WORD CLOSED_SQUARE assignments {
        auto section_name = std::string($2);

        configuration.insert_empty_section(section_name);
        configuration.modify_assignments_to_section(section_name, temp_assignments);
        
        temp_assignments.clear();
    }
;

assignments:
    // empty
    |
    assignments assignment {
    }
;

assignment: 
    WORD EQUALS NUMBER {
        temp_assignments[std::string($1)] = std::pair<Value, std::list<Value*>>(Value(std::stoi(std::string($3))), temp_empty_list); 
    }
	|
	WORD EQUALS STRING {
        temp_assignments[std::string($1)] = std::pair<Value, std::list<Value*>>(Value(std::string($3)), temp_empty_list);
    }
	|
	WORD EQUALS BOOL {
        temp_assignments[std::string($1)] = std::pair<Value, std::list<Value*>>(Value(to_bool(std::string($3))), temp_empty_list); 
    }
	|
	WORD EQUALS REFPATH {
        temp_assignments[std::string($1)] = std::pair<Value, std::list<Value*>>(Value(std::string($3), NULL), temp_empty_list);
    }
;

%%

// Mappa dei commenti fornita dal lexer
extern std::map<int, std::string> comments;

int main() {
    yyparse();

    // Aggiungere i riferimenti
    // Cosi facendo possiamo puntare ad una sezione non ancora esistente

    configuration.add_pointers_references();
	
    std::cout << configuration.to_String_with_comments(comments);
    //std::cout << configuration.to_String();

	return 0;
}

// Ritorna semplice messaggio di errore di parsing
void yyerror(const char* s) {
	std::cout << "Parse error: " << s << "\n";
	exit(1);
}
