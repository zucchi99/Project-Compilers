-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

-- module AbsGrammar where

module AbstractSyntax where

import qualified Types as T

data Position = Position { row, col :: Int }
  deriving (Show)

data Ident = Ident { id_name :: String, pos :: Position }
  deriving (Eq, Ord, Show, Read)

data Program = ProgramStart { p_name :: Ident, block_decl :: BlockWithDecl, pos :: Position }
  deriving (Eq, Ord, Show, Read)

data BlockWithDecl = BlockWithDeclaration { decl :: [Declaration], block_exec :: BlockExec, pos :: Position }
  deriving (Eq, Ord, Show, Read)

data BlockExec = BlockOnlyExecution { stmt :: [Statement], pos :: Position }
  deriving (Eq, Ord, Show, Read)

data Declaration
    = DeclarationCostantsBlock { c_decl :: [ConstantDecl], pos :: Position }
    | DeclarationVariablesBlock { v_decl :: [VariableDecl], pos :: Position }
    | DeclarationFunction { f_decl :: [DeclarationFunc], pos :: Position }
    | DeclarationProcedure { p_decl :: [DeclarationFunc], pos :: Position }
  deriving (Eq, Ord, Show, Read)

data ConstantDecl = ConstantDeclaration { c_name :: Ident, c_value :: RightExp, c_type :: BaseType, c_pos :: Position }
  deriving (Eq, Ord, Show, Read)

-- v_value can be empty/null
data VariableDecl = VariableDecl { v_name :: [Ident], v_type :: Type, v_value :: Maybe RightExp, v_pos :: Position }
  deriving (Eq, Ord, Show, Read)

-- NB v_value in params must be all nothing !
-- NB (f_body == Nothing) <==> is forward
data DeclarationFunc = DeclarationFunc { f_name :: Ident, f_params :: [VariableDecl], f_ret_type :: Type, f_body :: Maybe BlockWithDecl, f_pos :: Position }
  deriving (Eq, Ord, Show, Read)

-- NB v_value in params must be all nothing !
-- NB (p_body == Nothing) <==> is forward
data DeclarationFunc = DeclarationFunc { p_name :: Ident, p_params :: [VariableDecl], p_body :: Maybe BlockWithDecl, p_pos :: Position }
  deriving (Eq, Ord, Show, Read)

data Statement
    = StatementBlock { block :: BlockExec, pos :: Position }
    | StatementIf { cond :: RightExp, then_body :: Statement, else_body :: Maybe ElseBlock }
    | StatementFor { for_var :: Assign, cond :: RightExp, body :: Statement }
    | StatementWhile { cond :: RightExp, body :: Statement }
    | StatementRepeatUntil { body :: [Statement], cond :: RightExp }
    | StatementAssign { Assign }
    | StatementFunctionCall { f_name :: Ident, f_body :: [RightExp] }
    | StatementProcedureCalll { p_name :: Ident, p_body :: [RightExp] }
    | StatementWrite WritePrimitive
    | StatementRead ReadPrimitive
  deriving (Eq, Ord, Show, Read)

data ElseBlock = ElseBlock1 | ElseBlock2 Statement
  deriving (Eq, Ord, Show, Read)

data Assign = VariableAssignment LeftExp RightExp
  deriving (Eq, Ord, Show, Read)

data RightExp
    = RightExpOr RightExp RightExp
    | RightExpAnd RightExp RightExp
    | RightExpGreater RightExp RightExp
    | RightExpLess RightExp RightExp
    | RightExpGreaterEqual RightExp RightExp
    | RightExpLessEqual RightExp RightExp
    | RightExpEqual RightExp RightExp
    | RightExpPlus RightExp RightExp
    | RightExpMinus RightExp RightExp
    | RightExpTimes RightExp RightExp
    | RightExpDivide RightExp RightExp
    | RightExpMod RightExp RightExp
    | RightExpDiv RightExp RightExp
    | RightExpPower RightExp RightExp
    | RightExpNot RightExp
    | RightExpMinusUnary RightExp
    | RightExpPlusUnary RightExp
    | RightExpInteger Integer
    | RightExpReal Double
    | RightExpBoolean Boolean
    | RightExpChar Char
    | RightExpString String
    | RightExpFunctionCall FunctionCall
    | RightExpCopy LeftExp
  deriving (Eq, Ord, Show, Read)

data LeftExp
    = LeftExpIdent Ident
    | LeftExpArrayAccess LeftExp [RightExp]
    | LeftExpPointerValue LeftExp
    | LeftExpPointerAddress LeftExp
  deriving (Eq, Ord, Show, Read)

data Type = TypeBaseType BaseType | TypeCompositeType CompositeType
  deriving (Eq, Ord, Show, Read)

data BaseType
    = BaseType_integer
    | BaseType_real
    | BaseType_char
    | BaseType_boolean
    | BaseType_string
  deriving (Eq, Ord, Show, Read)

data Boolean = Boolean_true | Boolean_false
  deriving (Eq, Ord, Show, Read)

data CompositeType
    = CompTypeArray [ArrayDeclarationDim] BaseType
    | CompTypePointer Type
  deriving (Eq, Ord, Show, Read)

data ArrayDeclarationDim = ArrayDeclarationDim RightExp RightExp
  deriving (Eq, Ord, Show, Read)

data WritePrimitive
    = WriteInt RightExp
    | WriteReal RightExp
    | WriteChar RightExp
    | WriteString RightExp
  deriving (Eq, Ord, Show, Read)

data ReadPrimitive
    = ReadInt LeftExp
    | ReadReal LeftExp
    | ReadChar LeftExp
    | ReadString LeftExp
  deriving (Eq, Ord, Show, Read)

