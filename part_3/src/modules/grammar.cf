
-- comment: one argument for single-line comments
comment "//";
-- comment: two arguments for multi-line comments
comment "{" "}"; 
comment "(*" "*)";

-- entrypoints: set of initial states of the grammar
entrypoints Program;

-- __________ PASCAL KEYWORDS __________

KeyWordBegin.                   BeginKW         ::= "begin" ;
KeyWordEnd.                     EndKW           ::= "end" ;
KeyWordProgram.                 ProgramKW       ::= "program" ;
KeyWordFunction.                FunctionKW      ::= "function" ;
KeyWordProcedure.               ProcedureKW     ::= "procedure" ;
KeyWordVar.                     VarKW           ::= "var" ;
KeyWordConst.                   ConstKW         ::= "const" ;
KeyWordIf.                      IfKW            ::= "if" ;
KeyWordThen.                    ThenKW          ::= "then" ;
KeyWordElse.                    ElseKW          ::= "else" ;
KeyWordWhile.                   WhileKW         ::= "while" ;
KeyWordFor.                     ForKW           ::= "for" ;
KeyWordTo.                      ToKW            ::= "to" ;
KeyWordDo.                      DoKW            ::= "do" ;
KeyWordRepeat.                  RepeatKW        ::= "repeat" ;
KeyWordUntil.                   UntilKW         ::= "until" ;
KeyWordTypeInt.                 IntKW           ::= "integer";
KeyWordTypeReal.                RealKW          ::= "real";
KeyWordTypeChar.                CharKW          ::= "char";
KeyWordTypeBoolean.             BoolKW          ::= "boolean";
KeyWordTypeString.              StringKW        ::= "string";
KeyWordTypeArray.               ArrayKW         ::= "array";

-- program definition
ProgramStart.                   Program      ::= ProgramKW Ident ";" InnerBlockWithDecl "." ;

-- __________ BLOCK STRUCTURE __________

-- block structure with declarations
InnerBlockWithDeclaration.       InnerBlockWithDecl ::= [Declaration] InnerBlockExec ;
separator Declaration "" ;

-- Useful, because inside a begin ... end block there can be a nested block, only without declarations
InnerBlockOnlyExecution.         InnerBlockExec     ::= BeginKW NonMandatoryTerminator [Statement] EndKW ;
separator Statement ";" ;

rules                            NonMandatoryTerminator ::= {- empty -} | ";" ;

-- variables, functions, procedures
rules                           Declaration   ::= CostantsBlock | VariablesBlock | FunctionDecl | ProcedureDecl ; --Declaration

-- __________ COSTANTS DECLARATIONS __________

-- costants block declaration (cannot be empty)
rules                           CostantsBlock ::= ConstKW [ConstantDecl] ; -- CostantsBlock
terminator nonempty ConstantDecl ";" ;
ConstantDeclaration.            ConstantDecl  ::= Ident "=" RightExp ;

-- __________ VARIABLES DECLARATIONS __________

-- variables block declaration (cannot be empty)
rules                           VariablesBlock ::= VarKW [VariableDeclBlock] ; -- VariablesBlock. 

-- if i use VarKW I need to declare at least 1 variable
terminator nonempty VariableDeclBlock  ";" ;
-- Declaring a function, i don't want always to declare a variable
separator VariableDeclFunc  ";" ;

-- Variables Declaration inside var block
VariableDeclarationInsideBlock. VariableDeclBlock   ::= [Ident] ":" Type InitAssign ;
rules                           InitAssign          ::= {- empty -} | "=" RightExp ;        
-- Variables Declaration inside function parenthesis 
-- Exist the possibility to declare a function without paranthesis, if it has no parameters
rules                           DeclarationFunc     ::= {- empty -} | "(" [VariableDeclFunc] ")" ;
VariableDeclarationInsideF.     VariableDeclFunc    ::= [Ident] ":" Type ; 
separator nonempty Ident "," ;

-- __________ FUNCTION AND PROCEDURE DECLARATIONS __________

-- function and procedure declaration
FunctionDeclaration.            FunctionDecl   ::= FunctionKW  Ident DeclarationFunc ":" Type ";" InnerBlockWithDecl ";" ;
ProcedureDeclaration.           ProcedureDecl  ::= ProcedureKW Ident DeclarationFunc ";" InnerBlockWithDecl ";" ;

FunctionCall.                   FunctionCall   ::= Ident "(" [RightExp] ")" ;
ProcedureCall.                  ProcedureCall  ::= Ident "(" [RightExp] ")" ;
separator RightExp "," ;

-- __________ STATEMENTS __________

StatementBlock.                 Statement       ::= InnerBlockExec ;
StatementIf.                    Statement       ::= IfKW RightExp ThenKW Statement ElseBlock ;
StatementFor.                   Statement       ::= ForKW Assign ToKW RightExp DoKW Statement ;
StatementWhile.                 Statement       ::= WhileKW RightExp DoKW Statement ;
StatementRepeatUntil.           Statement       ::= RepeatKW [Statement] UntilKW RightExp ;
StatementAssign.                Statement       ::= Assign ;
StatementFunctionCall.          Statement       ::= FunctionCall ;
StatementProcedureCall.         Statement       ::= ProcedureCall ;
StatementWrite.                 Statement       ::= WritePrimitive ;
StatementRead.                  Statement       ::= ReadPrimitive ;

rules                           ElseBlock       ::= {- empty -} | ElseKW Statement ; --ElseDefinition

VariableAssignment.             Assign          ::= LeftExp ":=" RightExp;

-- __________ RIGHT EXPRESSIONS __________

coercions RightExp 7 ;
RightExpOr.                     RightExp        ::= RightExp "or" RightExp1 ;

RightExpAnd.                    RightExp1       ::= RightExp1 "and" RightExp2 ;

RightExpGreater.                RightExp2       ::= RightExp2 ">" RightExp3 ;
RightExpLess.                   RightExp2       ::= RightExp2 "<" RightExp3 ;
RightExpGreaterEqual.           RightExp2       ::= RightExp2 ">=" RightExp3 ;
RightExpLessEqual.              RightExp2       ::= RightExp2 "<=" RightExp3 ;
RightExpEqual.                  RightExp2       ::= RightExp2 "=" RightExp3 ;

RightExpPlus.                   RightExp3       ::= RightExp3 "+" RightExp4 ;
RightExpMinus.                  RightExp3       ::= RightExp3 "-" RightExp4 ;

RightExpTimes.                  RightExp4       ::= RightExp4 "*" RightExp5 ;
RightExpDivide.                 RightExp4       ::= RightExp4 "/" RightExp5 ;
RightExpMod.                    RightExp4       ::= RightExp4 "mod" RightExp5 ;
RightExpDiv.                    RightExp4       ::= RightExp4 "div" RightExp5 ;

RightExpPower.                  RightExp5       ::= RightExp5 "**" RightExp6 ;

RightExpNot.                    RightExp6       ::= "not" RightExp7 ;
RightExpMinusUnary.             RightExp6       ::= "-" RightExp7 ;
RightExpPlusUnary.              RightExp6       ::= "+" RightExp7 ;

RightExpInteger.                RightExp7       ::= Integer ;
RightExpReal.                   RightExp7       ::= Double ;
RightExpBoolean.                RightExp7       ::= Boolean ;
RightExpChar.                   RightExp7       ::= Char ;
RightExpString.                 RightExp7       ::= String ;
RightExpFunctionCall.           RightExp7       ::= FunctionCall ;
RightExpCopy.                   RightExp7       ::= LeftExp ;

-- __________ LEFT EXPRESSIONS __________

LeftExpIdent.                   LeftExp         ::= Ident ;
LeftExpArrayAccess.             LeftExp         ::= LeftExp "[" [RightExp] "]" ;
LeftExpPointerValue.            LeftExp         ::= LeftExp "^" ;
LeftExpPointerAddress.          LeftExp         ::= "@" LeftExp ;

-- __________ TYPES __________

-- basic types definition
rules                           Type            ::= BaseType | CompositeType ; --AnyType
rules                           BaseType        ::= IntKW | RealKW | CharKW | BoolKW | StringKW ; --BaseType
rules                           Boolean         ::= "true" | "false" ;

-- complex types definition
-- actually for arrays should be: array [0..5, 1..6] if multi-dimensional
CompTypeArray.                  CompositeType   ::= ArrayKW "[" [ArrayDeclarationDim] "]" "of" BaseType ;
separator ArrayDeclarationDim "," ;
-- The declaration with variable length is not allowed in Pascal, but here it's allowed
-- we need to be sure that the right expression produce an integer
ArrayDeclarationDim.            ArrayDeclarationDim     ::= RightExp ".." RightExp ;

-- Pointer of pointer in Pascal is not allowed, but here is allowed, BECAUSE THIS IS NOT PASCAL
CompTypePointer.                CompositeType   ::= "^" Type ;

-- __________ READ AND WRITE __________

WriteInt.                       WritePrimitive  ::= "writeInt" "(" RightExp ")" ;
WriteReal.                      WritePrimitive  ::= "writeReal" "(" RightExp ")" ;
WriteChar.                      WritePrimitive  ::= "writeChar" "(" RightExp ")" ;
WriteString.                    WritePrimitive  ::= "writeString" "(" RightExp ")" ;
ReadInt.                        ReadPrimitive   ::= "readInt" "(" LeftExp ")" ;
ReadReal.                       ReadPrimitive   ::= "readReal" "(" LeftExp ")" ;
ReadChar.                       ReadPrimitive   ::= "readChar" "(" LeftExp ")" ;
ReadString.                     ReadPrimitive   ::= "readString" "(" LeftExp ")" ;
